// Generated by CoffeeScript 1.6.3
(function() {
  var Crysto, EVENT, Events, STATUS, container, noop, _apply, _ref;

  container = typeof window !== "undefined" && window !== null ? window : exports;

  container.tl = (_ref = container.tl) != null ? _ref : {};

  noop = function() {};

  if (window.console == null) {
    window.console = {
      log: noop,
      info: noop,
      warn: noop,
      debug: noop,
      error: noop
    };
  }

  _apply = function(t, s) {
    var k, v, _results;
    _results = [];
    for (k in s) {
      v = s[k];
      _results.push(t[k] = v);
    }
    return _results;
  };

  Events = (function() {
    if (container.tl.Events) {
      return container.tl.Events;
    } else {
      throw new Error('Need tl.Events lib');
    }
  })();

  STATUS = {
    running: 'r',
    stopped: 's'
  };

  EVENT = {
    start: 'start',
    stop: 'stop',
    interval: 'interval'
  };

  Crysto = (function() {
    Crysto.statuses = STATUS;

    Crysto.events = EVENT;

    Crysto.prototype.status = STATUS.stopped;

    Crysto.prototype.o = {
      interval: 200
    };

    Crysto.prototype.events = null;

    Crysto.prototype.timerHandle = null;

    Crysto.prototype.startTime = -1;

    Crysto.prototype.stopTime = -1;

    Crysto.prototype.passed = 0;

    Crysto.prototype.nowDate = null;

    Crysto.prototype.now = 0;

    Crysto.prototype.intervalRounds = 0;

    Crysto.prototype.passedOffset = 0;

    function Crysto(o) {
      this.events = {};
      _apply(this.events, Events);
      if (o) {
        this.config(o);
        this.reset();
      }
    }

    Crysto.prototype.config = function(o) {
      if (o && o instanceof Object) {
        this.o = {};
        _apply(this.o, Crysto.prototype.o);
        return _apply(this.o, o);
      } else {
        throw Error('needs options object for configuring Crysto');
      }
    };

    Crysto.prototype.reset = function() {
      if (this.status === STATUS.running) {
        console.warn('the Crysto[' + this.timerHandle + '] is running now, it cannot be reset');
        return;
      }
      console.info('the Crysto[' + this.timerHandle + '] is reset');
      /*
      Init state to prepare for new starting
      */

      this.status = STATUS.stopped;
      this.timerHandle = -1;
      this.nowDate = null;
      this.now = -1;
      this.startTime = -1;
      this.stopTime = -1;
      this.passed = 0;
      this.intervalRounds = 0;
      return this.passedOffset = 0;
    };

    Crysto.prototype.start = function() {
      var intervalFn, me;
      if (this.status === STATUS.running) {
        console.warn('the Crysto[' + this.timerHandle + '] is running now, it cannot be started again until stopped');
        return;
      }
      this.status = STATUS.running;
      this.nowDate = new Date();
      this.now = this.nowDate.getTime();
      this.startTime = this.now;
      /*
      Init state for starting
      */

      this.timerHandle = -1;
      this.stopTime = -1;
      this.passed = 0;
      this.intervalRounds = 0;
      this.passedOffset = 0;
      me = this;
      intervalFn = function() {
        if (me.status !== STATUS.running) {
          console.warn('the Crysto[' + me.timerHandle + '] is already stopped, no more intervals');
        } else {
          return me.intervalProcessor();
        }
      };
      this.timerHandle = window.setInterval(intervalFn, this.o.interval);
      console.info('the Crysto[' + this.timerHandle + '] is started');
      return this.events.trigger(EVENT.start);
    };

    Crysto.prototype.stop = function() {
      if (this.status !== STATUS.running) {
        console.warn('the Crysto[' + this.timerHandle + '] is not running now, no need to stop it');
        return;
      }
      this.status = STATUS.stopped;
      this.nowDate = new Date();
      this.now = this.nowDate.getTime();
      this.stopTime = this.now;
      this.passed = this.now - this.startTime;
      window.clearInterval(this.timerHandle);
      console.info('the Crysto[' + this.timerHandle + '] is stopped');
      return this.events.trigger(EVENT.stop);
    };

    Crysto.prototype.intervalProcessor = function() {
      this.nowDate = new Date();
      this.now = this.nowDate.getTime();
      this.passed = this.now - this.startTime;
      this.intervalRounds++;
      this.passedOffset = this.passed - this.intervalRounds * this.o.interval;
      return this.events.trigger(EVENT.interval);
    };

    Crysto.prototype.on = function(event, callback, context) {
      if (event) {
        this.support(event);
      }
      return this.events.on(event, callback, context);
    };

    Crysto.prototype.off = function(event, callback, context) {
      if (event) {
        this.support(event);
      }
      return this.events.off(event, callback, context);
    };

    Crysto.prototype.support = function(event) {
      var i;
      if (i = event.indexOf(':') !== -1) {
        event = event.substring(0, i);
      }
      if (EVENT[event]) {
        return true;
      } else {
        console.warn('Crysto does not support event: #{event}');
        return false;
      }
    };

    return Crysto;

  })();

  container.tl.Crysto = Crysto;

}).call(this);
